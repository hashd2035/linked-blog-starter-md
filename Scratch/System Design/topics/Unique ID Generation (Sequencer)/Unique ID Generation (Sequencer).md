---
icon: luc_briefcase
---
```toc
```
Unique IDs identifies events and objects in a distributed systems.
## Use case

- Events happening in order, such as a post on Facebook, sharing a Tweet, and posting a picture on Instagram
- Assigning a primary key to an entry in a database
	- In a single instance of database, auto-increment feature in databases fulfills the requirement
		- Won't work for a distributed database, where different nodes independently generate the identifiers. e.g. Horizontal sharding
* A unique ID helps us identify the flow of an event in the logs and is useful for debugging. e.g. Facebook’s end-to-end performance tracing and analysis system, Canopy.
	* Canopy uses TraceID to identify an event uniquely across the execution path that potentially perform hundreds of microservices to fulfil one user request.
![[Pasted image 20240325143316.png]]
## Requirements

- Uniqueness 
- Availability
- Scalability 
	- 64-bit numeric ID 
		- Total numbers = $2^{64}$ = 1.8446744 x $10^{19}$ 
		- Estimated number of events per day = 1 billion = $10^9$
		- Number of events per day = 365 x $10^9$
		- Number of years to deplete identifier range = $2^{64}$ / (365 x $10^9$) = 50,539,024 years
		- should be enough

## 1. Design of a unique ID Generator
3 ways to generate unique IDs: Using UUID, using a database, and using a range handler

### UUID (Universally Unique IDs)
also known as GUID (Globally Unique IDs)

> - 128-bit number and 
> - looks like 123e4567e89b12d3a456426614174000 in hexadecimal.
> - gives us $10^{38}$ numbers
> - UUIDs have different versions. 
> 	- One of them is version 4, which generates a pseudorandom number
#### Pros
- Each server can generate its own ID and assign the ID to its respective event. 
- No coordination is needed for UUID since it’s independent of the server. 
- Scaling up and down is easy with UUID, and this system is also highly available.
- It has a low probability of collisions
#### Cons
- Using 128-bit numbers as primary keys makes the primary-key indexing slower, which results in slow inserts
	- A workaround might be to interpret an ID as a hex string instead of a number.
	- Non-numeric identifiers might not be suitable for many use cases
- There's chance of duplication. Although this chance is minimal, we can't claim UUID to be deterministically unique.
- UUIDs given to clients over time might not be monotonically increasing.
### Using a database
A central database that provides a current ID and then <u>increments the value by one</u>. We can use the current ID as a unique identifier for our events.

The problem is the central server becomes SPOF (Single Point of Failure)

So, we can modify such that we reply on a value `m` 
- where `m` equals the number of database servers we have. 
- Each server generates an ID, and 
- the following ID adds `m` to the previous value. 

This method is scalable and prevents the duplication of IDs.

![[Unique ID Generation using database]]
#### Pros
- Scalable. We can add more servers, and the value of `m` will be updated accordingly.
#### Cons
- Difficult to scale for multiple data centers. 
- The task of adding and removing a server can result in duplicate IDs. 
	- For example, suppose `m=3`, and 
		- Server A generates the unique IDs 1, 4, and 7. 
		- Server B generates the IDs 2, 5, and 8, while 
		- server C generates the IDs 3, 6, and 9. 
		- Server B faces downtime due to some failure. 
		- Now, the value `m` is updated to 2. 
		- Server A generates 9 as its following unique ID, but this ID has already been generated by server C. 
		- Therefore, the IDs aren’t unique anymore.

### Range Handler

To overcome the problems identified in the previous methods, we can use ranges in a central server. Suppose we have multiple ranges for one to two billion, such as 1 to 1,000,000; 1,000,001 to 2,000,000; and so on. In such a case, a central microservice can provide a range to a server upon request.

![[Unique ID Generation using Range handler]]
#### Pros
This system is scalable, available, and yields user IDs that have no duplicates. 
Moreover, we can maintain this range in 64 bits, which is numeric.
#### Cons
We lose a significant range when a server dies and can only provide a new range once it’s live again. We can overcome this shortcoming by allocating shorter ranges to the servers, although ranges should be large enough to serve identifiers for a while.

### Summary

|          | Unique | Scalable | Available | 64-bit numeric ID |
| :------: | :----: | :------: | :-------: | :---------------: |
|   UUID   |   X    |    O     |     O     |         X         |
| Database |   X    |    X     |     O     |         O         |
|  Range   |   O    |    O     |     O     |         O         |

## 2. Unique IDs with <u>Causality</u>
incorporate additional factor of time in the generation of IDs and explain the process by taking causality into consideration

[[Clocks]]

- [ ] Continue with this https://www.educative.io/courses/grokking-modern-system-design-interview-for-engineers-managers/unique-ids-with-causality


## Related Case Studies
[[Scratch/System Design/case-studies/URL Shortener/URL Shortener]]
[[Whatsapp]]

